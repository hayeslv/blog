# Event Loop



## GUI渲染线程为什么与JS引擎线程互斥

这样由于 `JS` 是可以操作 `DOM` 的。如果同时修改元素属性并同时渲染界面（即**JS线程**和**UI线程**同时执行），那么渲染线程前后活的的元素就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器设定**GUI渲染线程**和**JS引擎线程**为互斥关系。

当**JS引擎线程**执行时**GUI渲染线程**会被挂起，GUI更新则会被保存在一个队列中等待**JS引擎线程**空闲时立即被执行。



## 从 EventLoop 看 JS 的运行机制

- `JS` 分为同步任务和异步任务
- 同步任务都在**JS引擎线程**上执行，形成一个执行栈
- **事件触发线程**管理一个**任务队列**，异步任务触发条件达成，将回调事件放入任务队列中
- 执行栈中所有同步任务执行完毕，此时**JS引擎线程**空闲，系统会读取**任务队列**，将可运行的**异步任务回调事件**添加到执行栈中，开始执行

<img src=".\assets\3.png" alt="3" style="zoom: 50%;" />

- 前端开发中我们会通过 `setTimeout/setInterval` 来指定定时任务，会通过 `XHR/fetch` 发送网络请求；
- `setTimeout/setInterval` 和 `XHR/fetch` 这些代码执行时，本身是**同步任务**，而其中的回调函数才是**异步任务**；
- 当代码执行到 `setTimeout/setInterval` 时，实际上**JS引擎线程**会通知**定时触发器线程**，间隔一个时间后，会触发一个回调事件；
- 而**定时触发器线程**在接收到这个消息后，会在等待的时间后，将回调事件放入由**事件触发线程**所管理的事件队列中；
- 当代码执行到 `XHR/fetch` 时，实际上是**JS引擎线程**通知**异步 `http` 请求线程**，发送一个网络请求，并制定请求完成后的回调事件；
- 而异步 `http` 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由**事件触发线程**所管理的**事件队列**中；
- 当我们的同步任务执行完，**JS引擎线程**会询问**事件触发线程**，在**事件队列**中是否有待执行的回调函数，如果有就会加入到执行栈中交给**JS引擎线程**执行。

```js
let timerCallback = function() {
  console.log("wait one second")
}
let httpCallback = function() {
  console.log("get server data success")
}
// 同步任务
console.log("hello")
// 同步任务
// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理
// 1s 后事件触发线程将 timerCallback 加入到事件队列中
setTimeout(timerCallback, 1000)
// 同步任务
// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理
// 请求成功后事件触发线程将 httpCallback 加入到事件队列中
$.get("www.xxx.com", httpCallback)
// 同步任务
console.log("world")
// ...
// 所有同步任务执行完成后
// 询问事件触发线程在事件队列中是否有需要执行的回调函数
// 如果没有，则一直询问，直到有为止
// 如果有，将回调事件加入执行栈中，开始执行回调代码
```

**总结：**

- **JS引擎线程**只执行执行栈中的事件；
- 执行栈中的代码执行完毕，就会读取事件队列中的事件；
- 事件队列中的回调事件，是由各自线程插入到事件队列中的；
- 如此循环







































