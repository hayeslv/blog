# Event Loop



## GUI渲染线程为什么与JS引擎线程互斥

这样由于 `JS` 是可以操作 `DOM` 的。如果同时修改元素属性并同时渲染界面（即**JS线程**和**UI线程**同时执行），那么渲染线程前后活的的元素就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器设定**GUI渲染线程**和**JS引擎线程**为互斥关系。

当**JS引擎线程**执行时**GUI渲染线程**会被挂起，GUI更新则会被保存在一个队列中等待**JS引擎线程**空闲时立即被执行。



## 从 EventLoop 看 JS 的运行机制

- `JS` 分为同步任务和异步任务
- 同步任务都在**JS引擎线程**上执行，形成一个执行栈
- **事件触发线程**管理一个**任务队列**，异步任务触发条件达成，将回调事件放入任务队列中
- 执行栈中所有同步任务执行完毕，此时**JS引擎线程**空闲，系统会读取**任务队列**，将可运行的**异步任务回调事件**添加到执行栈中，开始执行

<img src=".\assets\3.png" alt="3" style="zoom: 50%;" />

- 前端开发中我们会通过 `setTimeout/setInterval` 来指定定时任务，会通过 `XHR/fetch` 发送网络请求；
- `setTimeout/setInterval` 和 `XHR/fetch` 这些代码执行时，本身是**同步任务**，而其中的回调函数才是**异步任务**；
- 当代码执行到 `setTimeout/setInterval` 时，实际上**JS引擎线程**会通知**定时触发器线程**，间隔一个时间后，会触发一个回调事件；
- 而**定时触发器线程**在接收到这个消息后，会在等待的时间后，将回调事件放入由**事件触发线程**所管理的事件队列中；
- 当代码执行到 `XHR/fetch` 时，实际上是**JS引擎线程**通知**异步 `http` 请求线程**，发送一个网络请求，并制定请求完成后的回调事件；
- 而异步 `http` 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由**事件触发线程**所管理的**事件队列**中；
- 当我们的同步任务执行完，**JS引擎线程**会询问**事件触发线程**，在**事件队列**中是否有待执行的回调函数，如果有就会加入到执行栈中交给**JS引擎线程**执行。

```js
let timerCallback = function() {
  console.log("wait one second")
}
let httpCallback = function() {
  console.log("get server data success")
}
// 同步任务
console.log("hello")
// 同步任务
// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理
// 1s 后事件触发线程将 timerCallback 加入到事件队列中
setTimeout(timerCallback, 1000)
// 同步任务
// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理
// 请求成功后事件触发线程将 httpCallback 加入到事件队列中
$.get("www.xxx.com", httpCallback)
// 同步任务
console.log("world")
// ...
// 所有同步任务执行完成后
// 询问事件触发线程在事件队列中是否有需要执行的回调函数
// 如果没有，则一直询问，直到有为止
// 如果有，将回调事件加入执行栈中，开始执行回调代码
```

**总结：**

- **JS引擎线程**只执行执行栈中的事件；
- 执行栈中的代码执行完毕，就会读取事件队列中的事件；
- 事件队列中的回调事件，是由各自线程插入到事件队列中的；
- 如此循环



## 什么是宏任务

- 我们可以将每次执行栈中执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）；
- 每一个宏任务会从头到尾执行完毕，不会执行其他。

> JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行完成后，在下一个宏任务执行前，让GUI渲染线程开始工作，对页面进行渲染。

```js
// 宏任务 --> 渲染 --> 宏任务 --> 渲染 --> ...
```

主代码块、`setTimeout`、`setInterval` 等，都属于宏任务



### 示例1

```js
document.body.style = "background:black";
document.body.style = "background:red";
document.body.style = "background:blue";
document.body.style = "background:grey";
```

我们看到的结果是，页面背景会在瞬间变成灰色。这是因为以上代码属于同一次**宏任务**，所以全部执行完才触发页面渲染，渲染时**GUI线程**会将所有UI的改动优化合并，所以视觉效果上，只会看到页面变成灰色。



### 示例2

```js
document.body.style = "background:blue";
setTimeout(function() {
  document.body.style = "background:black";
}, 0)
```

页面会闪一下蓝色背景，然后瞬间变成黑色背景，这是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色。



## 什么是微任务

- 我们已经知道**宏任务**结束后，会执行渲染，然后执行下一个**宏任务**；
- 而**微任务**可以理解成在当前**宏任务**执行后立即执行的任务；
- 也就是说：当**宏任务**执行完，会在渲染前，将执行期间所产生的所有**微任务**都执行完

`Promise`、`process.nextTick`等，属于微任务



### 示例1

```js
document.body.style = "background:blue"
console.log(1)
Promise.resolve().then(() => {
  console.log(2)
  document.body.style = "background:black"
})
console.log(3)
```

- 控制台输出 `1 3 2`，是因为 `promise` 对象的 `then` 方法的回调函数是异步执行，所以 2 最后输出
- 页面的背景直接变成黑色，没有经过蓝色的阶段，是因为我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染



### 示例2

```js
setTimeout(() => {
  console.log(1)
  Promise.resolve(3).then(data => console.log(data))
}, 0)
setTimeout(() => {
  console.log(2)
}, 0)
// 打印结果：1 3 2
```

上述代码共包含两个 `setTimeout`，也就是说除了主代码块外，共有两个宏任务，其中第一个宏任务执行中，输出 1，并且创建了微任务队列，所以在下一个宏任务队列执行前，会先执行微任务；在微任务执行中，输出 3；微任务执行后，执行下一次宏任务，执行中输出2 。



## 总结

- 执行一个**宏任务**（栈中没有就从事件队列中获取）
- 执行过程中如果遇到**微任务**，就将它添加到**微任务的任务队列**中
- **宏任务**执行完毕后，立即执行**当前微任务队列中的所有微任务**（依次执行）
- 当前**宏任务**执行完毕，开始检查**渲染**，然后**GUI线程**接管渲染
- 渲染完毕后，**JS线程**继续接管，开始下一个宏任务（从事件队列中获取）

<img src=".\assets\4.png" alt="4" style="zoom:50%;" />



















